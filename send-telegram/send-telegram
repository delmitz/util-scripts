#!/usr/bin/env bash
# ============================================================
# send-telegram - Send messages via Telegram Bot API
# Scheduled messages use a file-based job queue + daemon
# ============================================================

OS="$(uname)"

BASE_DIR="${HOME}/.send-telegram"
JOB_DIR="${BASE_DIR}/jobs"
PID_FILE="${BASE_DIR}/daemon.pid"
LOG_FILE="${BASE_DIR}/daemon.log"
CONFIG_FILE="${BASE_DIR}/config"
CHECK_INTERVAL=60   # seconds between queue checks
LOG_MAX_SIZE=512    # KB - rotate log when exceeded
MAX_RETRIES=3       # max send attempts per job before giving up

SELF="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "${BASH_SOURCE[0]}")"

# -------------------------------------------------------
# Returns the bot token from config, or returns 1 if not set
resolve_bot_token() {
    local from_config
    from_config=$(grep '^BOT_TOKEN=' "$CONFIG_FILE" 2>/dev/null | cut -d= -f2-)
    [[ -n "$from_config" ]] && echo "$from_config" && return 0
    return 1
}

# -------------------------------------------------------
usage() {
    cat <<EOF
Usage: send-telegram [-c <chat_id>] [-s <schedule>] <<< "message"
       echo "message" | send-telegram [-c <chat_id>] [-s <schedule>]

Send options:
  -c, --chat-id <id>        Telegram chat ID
                            (can be omitted if a default is saved)
  -s, --schedule <spec>     Schedule delivery:
                              +N            N minutes from now
                              HHmm          specific time today (local time)
                              yyyyMMddHHmm  specific date and time (local time)
  -i, --interactive         Read message interactively from terminal

Job management:
  --list-jobs               Show pending scheduled jobs and daemon status
  --cancel <job_id>         Cancel a scheduled job by ID

Configuration:
  --set-bot-token <token>   Save bot token to ${CONFIG_FILE}
  --set-chat-id <id>        Save default chat ID to ${CONFIG_FILE}

Help:
  --setup                   Show installation guide
  -h, --help                Show this help

Resolution order:  bot token: ${CONFIG_FILE} > error
                   chat_id:   -c option > ${CONFIG_FILE} > error

Examples:
  echo "Hello" | send-telegram -c 123456789
  send-telegram <<< "Hello"                          # uses saved default chat_id
  send-telegram -s +30 <<< "Send in 30 minutes"
  send-telegram -s 1430 <<< "Send at 14:30 today"
  send-telegram -s 202603011430 <<< "Send at specific datetime"
  send-telegram --set-bot-token "123456789:ABCdef..."
  send-telegram --set-chat-id 123456789
  send-telegram --list-jobs
  send-telegram --cancel 1740000000_abcd1234
EOF

    if ! resolve_bot_token > /dev/null 2>&1; then
        echo "" >&2
        echo "WARNING: Bot token is not configured." >&2
        echo "         Run 'send-telegram --set-bot-token <token>'" >&2
        echo "         or 'send-telegram --setup' for instructions." >&2
    fi
}

die() {
    echo "Error: $*" >&2
    exit 1
}

# -------------------------------------------------------
b64_encode() {
    base64 | tr -d '\n'
}

b64_decode() {
    if [[ "$OS" == "Darwin" ]]; then
        base64 -D
    else
        base64 -d
    fi
}

# -------------------------------------------------------
send_message() {
    local bot_token="$1" chat_id="$2" text="$3"

    local tmp_file
    tmp_file=$(mktemp)
    # shellcheck disable=SC2064
    trap "rm -f '$tmp_file'" RETURN

    local http_code
    http_code=$(curl -s -X POST \
        "https://api.telegram.org/bot${bot_token}/sendMessage" \
        -d "chat_id=${chat_id}" \
        --data-urlencode "text=${text}" \
        -o "$tmp_file" \
        -w "%{http_code}")

    local body
    body=$(cat "$tmp_file")

    if [[ "$http_code" != "200" ]]; then
        echo "Error: HTTP ${http_code} - ${body}" >&2
        return 1
    fi

    if ! echo "$body" | grep -q '"ok":true'; then
        echo "Error: Telegram API failure - ${body}" >&2
        return 1
    fi

    echo "Sent. (chat_id=${chat_id})"
}

# -------------------------------------------------------
# Returns target UNIX timestamp. Past times trigger immediate send.
parse_schedule() {
    local spec="$1"
    local now target
    now=$(date +%s)

    if [[ "$spec" =~ ^\+([0-9]+)$ ]]; then
        local minutes="${BASH_REMATCH[1]}"
        [[ "$minutes" -eq 0 ]] && die "+0 makes no sense"
        target=$((now + minutes * 60))

    elif [[ "$spec" =~ ^([0-9]{2})([0-9]{2})$ ]]; then
        local hh="${BASH_REMATCH[1]}" mm="${BASH_REMATCH[2]}"
        if [[ "$OS" == "Darwin" ]]; then
            target=$(date -j -f "%Y%m%d%H%M%S" "$(date +%Y%m%d)${hh}${mm}00" +%s 2>/dev/null) \
                || die "Invalid time: $spec"
        else
            target=$(date -d "$(date +%Y-%m-%d) ${hh}:${mm}:00" +%s 2>/dev/null) \
                || die "Invalid time: $spec"
        fi
        if [[ "$target" -le "$now" ]]; then
            echo "Warning: ${spec} has already passed today, sending immediately." >&2
            target=$now
        fi

    elif [[ "$spec" =~ ^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})$ ]]; then
        local yyyy="${BASH_REMATCH[1]}" mo="${BASH_REMATCH[2]}" dd="${BASH_REMATCH[3]}"
        local hh="${BASH_REMATCH[4]}" mi="${BASH_REMATCH[5]}"
        if [[ "$OS" == "Darwin" ]]; then
            target=$(date -j -f "%Y%m%d%H%M%S" "${spec}00" +%s 2>/dev/null) \
                || die "Invalid datetime: $spec"
        else
            target=$(date -d "${yyyy}-${mo}-${dd} ${hh}:${mi}:00" +%s 2>/dev/null) \
                || die "Invalid datetime: $spec"
        fi
        if [[ "$target" -le "$now" ]]; then
            echo "Warning: ${spec} has already passed, sending immediately." >&2
            target=$now
        fi

    else
        die "Invalid schedule format: '$spec'
Valid formats:
  +N           (e.g. +30 = 30 minutes from now)
  HHmm         (e.g. 1430 = 14:30 today)
  yyyyMMddHHmm (e.g. 202603011430)"
    fi

    echo "$target"
}

# -------------------------------------------------------
ensure_base_dir() {
    if [[ ! -d "$BASE_DIR" ]]; then
        mkdir -p "$BASE_DIR"
        chmod 700 "$BASE_DIR"
    fi
}

write_job() {
    local bot_token="$1" chat_id="$2" send_at="$3" message="$4"

    ensure_base_dir
    mkdir -p "$JOB_DIR"
    chmod 700 "$JOB_DIR"

    local rand
    rand=$(od -An -N4 -tx4 /dev/urandom 2>/dev/null | tr -d ' \n') || rand="${$}_${RANDOM}"
    local job_id="${send_at}_${rand}"
    local job_file="${JOB_DIR}/${job_id}.job"

    local msg_b64
    msg_b64=$(printf '%s' "$message" | b64_encode)

    cat > "$job_file" <<EOF
SEND_AT=${send_at}
CHAT_ID=${chat_id}
BOT_TOKEN=${bot_token}
MESSAGE_B64=${msg_b64}
EOF
    chmod 600 "$job_file"

    echo "$job_id"
}

# -------------------------------------------------------
load_default_chat_id() {
    [[ -f "$CONFIG_FILE" ]] || return 1
    local saved
    saved=$(grep '^DEFAULT_CHAT_ID=' "$CONFIG_FILE" 2>/dev/null | cut -d= -f2-)
    [[ -n "$saved" ]] && echo "$saved"
}

save_config_key() {
    local key="$1" value="$2"
    ensure_base_dir
    if [[ -f "$CONFIG_FILE" ]] && grep -q "^${key}=" "$CONFIG_FILE"; then
        if [[ "$OS" == "Darwin" ]]; then
            sed -i '' "s|^${key}=.*|${key}=${value}|" "$CONFIG_FILE"
        else
            sed -i "s|^${key}=.*|${key}=${value}|" "$CONFIG_FILE"
        fi
    else
        echo "${key}=${value}" >> "$CONFIG_FILE"
    fi
    chmod 600 "$CONFIG_FILE"
}

save_bot_token() {
    save_config_key "BOT_TOKEN" "$1"
    echo "Bot token saved. (${CONFIG_FILE})"
}

save_chat_id() {
    save_config_key "DEFAULT_CHAT_ID" "$1"
    echo "Default chat_id saved: $1 (${CONFIG_FILE})"
}

# -------------------------------------------------------
show_setup() {
    local system_bin user_bin
    if [[ "$OS" == "Darwin" ]]; then
        if [[ -d "/opt/homebrew/bin" ]]; then
            system_bin="/opt/homebrew/bin"
        elif [[ -d "/usr/local/bin" ]]; then
            system_bin="/usr/local/bin"
        else
            system_bin="/usr/local/bin"
        fi
        user_bin="${HOME}/.local/bin"
    else
        system_bin="/usr/local/bin"
        user_bin="${HOME}/.local/bin"
    fi

    echo "============================================================"
    echo "  send-telegram - Installation Guide"
    echo "============================================================"
    echo ""

    # --- Step 1: Install ---
    echo "Step 1: Install script to PATH"
    echo ""
    echo "  [1] System-wide  : ${system_bin}/send-telegram  (requires sudo)"
    echo "  [2] Current user : ${user_bin}/send-telegram"
    echo "  [s] Skip"
    echo ""
    local choice
    read -r -p "Choose [1/2/s]: " choice

    case "$choice" in
        1)
            if [[ "$OS" == "Darwin" && ! -d "$system_bin" ]]; then
                echo "Creating ${system_bin}..."
                sudo mkdir -p "$system_bin" || { echo "Failed to create ${system_bin}." >&2; }
            fi
            echo "Running: sudo cp \"${SELF}\" ${system_bin}/send-telegram"
            if sudo cp "$SELF" "${system_bin}/send-telegram" && \
               sudo chmod +x "${system_bin}/send-telegram"; then
                echo "Installed: ${system_bin}/send-telegram"
            else
                echo "Installation failed." >&2
            fi
            ;;
        2)
            mkdir -p "$user_bin"
            if cp "$SELF" "${user_bin}/send-telegram" && \
               chmod +x "${user_bin}/send-telegram"; then
                echo "Installed: ${user_bin}/send-telegram"
                if [[ ":${PATH}:" != *":${user_bin}:"* ]]; then
                    echo ""
                    if [[ "$OS" == "Darwin" ]]; then
                        echo "  Note: add to ~/.zshrc to make it permanent:"
                    else
                        echo "  Note: add to ~/.bashrc or ~/.zshrc to make it permanent:"
                    fi
                    echo "    export PATH=\"\$HOME/.local/bin:\$PATH\""
                fi
            else
                echo "Installation failed." >&2
            fi
            ;;
        *)
            echo "Skipped."
            echo "  Manual install:"
            echo "    sudo cp \"${SELF}\" ${system_bin}/send-telegram"
            echo "    sudo chmod +x ${system_bin}/send-telegram"
            ;;
    esac

    # --- Steps 2-4: Informational ---
    cat <<EOF

Step 2: Set your Telegram bot token
  send-telegram --set-bot-token "123456789:ABCdef..."

  To create a bot and get a token:
    1. Open Telegram, search for @BotFather
    2. Send /newbot and follow the prompts
    3. Copy the token (format: 123456789:ABCdef...)

Step 3: Save your default chat ID (optional, lets you omit -c)
  send-telegram --set-chat-id YOUR_CHAT_ID

  To find your chat ID:
    1. Send any message to your bot
    2. Open in browser:
       https://api.telegram.org/bot<TOKEN>/getUpdates
    3. Look for "chat":{"id": <number>}

Step 4: Test
  echo "Hello from send-telegram!" | send-telegram

============================================================
EOF

    local token_status chat_status
    if resolve_bot_token > /dev/null 2>&1; then
        token_status="configured"
    else
        token_status="NOT SET  <-- required"
    fi
    local default_chat
    default_chat=$(load_default_chat_id)
    chat_status="${default_chat:-(not set)}"

    echo "Current config (${CONFIG_FILE}):"
    echo "  Bot token:       ${token_status}"
    echo "  Default chat_id: ${chat_status}"
}

# -------------------------------------------------------
list_jobs() {
    if [[ -f "$PID_FILE" ]]; then
        local pid
        pid=$(cat "$PID_FILE" 2>/dev/null)
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            echo "Daemon: running (PID=${pid})"
        else
            echo "Daemon: not running (stale PID file)"
            rm -f "$PID_FILE"
        fi
    else
        echo "Daemon: not running"
    fi
    echo ""

    local found=0
    for job_file in "${JOB_DIR}"/*.job; do
        [[ -f "$job_file" ]] || continue
        found=1

        local send_at chat_id
        send_at=$(grep '^SEND_AT=' "$job_file" | cut -d= -f2-)
        chat_id=$(grep '^CHAT_ID=' "$job_file" | cut -d= -f2-)

        local target_time
        if [[ "$OS" == "Darwin" ]]; then
            target_time=$(date -r "$send_at" "+%Y-%m-%d %H:%M:%S")
        else
            target_time=$(date -d "@${send_at}" "+%Y-%m-%d %H:%M:%S")
        fi

        local job_id retries
        job_id=$(basename "$job_file" .job)
        retries=$(cat "${JOB_DIR}/${job_id}.retry" 2>/dev/null || echo 0)

        printf "%-42s  chat_id=%-15s  at=%s  retries=%s/%s\n" \
            "$job_id" "$chat_id" "$target_time" "$retries" "$MAX_RETRIES"
    done

    [[ "$found" -eq 0 ]] && echo "No pending jobs."
}

cancel_job() {
    local job_id="$1"
    local job_file="${JOB_DIR}/${job_id}.job"
    [[ -f "$job_file" ]] || die "Job not found: $job_id"
    rm -f "$job_file" "${JOB_DIR}/${job_id}.retry"
    echo "Cancelled: $job_id"
}

# -------------------------------------------------------
rotate_log_if_needed() {
    [[ -f "$LOG_FILE" ]] || return 0

    local size_kb
    if [[ "$OS" == "Darwin" ]]; then
        size_kb=$(( $(stat -f%z "$LOG_FILE" 2>/dev/null || echo 0) / 1024 ))
    else
        size_kb=$(( $(stat -c%s "$LOG_FILE" 2>/dev/null || echo 0) / 1024 ))
    fi

    if [[ "$size_kb" -ge "$LOG_MAX_SIZE" ]]; then
        mv "$LOG_FILE" "${LOG_FILE}.1"
    fi
}

# -------------------------------------------------------
ensure_daemon() {
    if [[ -f "$PID_FILE" ]]; then
        local pid
        pid=$(cat "$PID_FILE" 2>/dev/null)
        if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
            return 0  # already running
        fi
        rm -f "$PID_FILE"
    fi

    ensure_base_dir
    rotate_log_if_needed
    nohup "$SELF" --daemon-loop >> "$LOG_FILE" 2>&1 &
    local daemon_pid=$!
    echo "$daemon_pid" > "$PID_FILE"
    disown "$daemon_pid"
    echo "Daemon started (PID: ${daemon_pid}, log: ${LOG_FILE})" >&2
}

# -------------------------------------------------------
run_daemon_loop() {
    echo $$ > "$PID_FILE"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Daemon started (PID=$$, interval=${CHECK_INTERVAL}s, max_retries=${MAX_RETRIES})"

    while true; do
        local now
        now=$(date +%s)

        for job_file in "${JOB_DIR}"/*.job; do
            [[ -f "$job_file" ]] || continue

            local send_at chat_id bot_token msg_b64
            send_at=$(grep '^SEND_AT='     "$job_file" | cut -d= -f2-)
            chat_id=$(grep '^CHAT_ID='     "$job_file" | cut -d= -f2-)
            bot_token=$(grep '^BOT_TOKEN=' "$job_file" | cut -d= -f2-)
            msg_b64=$(grep '^MESSAGE_B64=' "$job_file" | cut -d= -f2-)

            if [[ -z "$send_at" || -z "$chat_id" || -z "$bot_token" || -z "$msg_b64" ]]; then
                echo "[$(date '+%Y-%m-%d %H:%M:%S')] SKIP malformed job: $(basename "$job_file")"
                continue
            fi

            if [[ "$send_at" -le "$now" ]]; then
                local job_id retry_file retries
                job_id=$(basename "$job_file" .job)
                retry_file="${JOB_DIR}/${job_id}.retry"
                retries=$(cat "$retry_file" 2>/dev/null || echo 0)

                local message
                message=$(printf '%s' "$msg_b64" | b64_decode 2>/dev/null)

                local result
                if result=$(send_message "$bot_token" "$chat_id" "$message" 2>&1); then
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] OK   $(basename "$job_file"): $result"
                    rm -f "$job_file" "$retry_file"
                else
                    retries=$((retries + 1))
                    echo "[$(date '+%Y-%m-%d %H:%M:%S')] FAIL $(basename "$job_file") (attempt ${retries}/${MAX_RETRIES}): $result"
                    if [[ "$retries" -ge "$MAX_RETRIES" ]]; then
                        echo "[$(date '+%Y-%m-%d %H:%M:%S')] GIVE UP $(basename "$job_file") after ${MAX_RETRIES} attempts"
                        rm -f "$job_file" "$retry_file"
                    else
                        echo "$retries" > "$retry_file"
                    fi
                fi
            fi
        done

        # Find earliest pending job and compute adaptive sleep duration
        local next_send_at=0
        for job_file in "${JOB_DIR}"/*.job; do
            [[ -f "$job_file" ]] || continue
            local job_at
            job_at=$(grep '^SEND_AT=' "$job_file" | cut -d= -f2-)
            [[ -z "$job_at" ]] && continue
            if [[ "$next_send_at" -eq 0 || "$job_at" -lt "$next_send_at" ]]; then
                next_send_at="$job_at"
            fi
        done

        if [[ "$next_send_at" -eq 0 ]]; then
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] No pending jobs, daemon exiting."
            rm -f "$PID_FILE"
            exit 0
        fi

        local until_next sleep_secs
        until_next=$(( next_send_at - $(date +%s) ))
        if [[ "$until_next" -le 1 ]]; then
            sleep_secs=1
        elif [[ "$until_next" -lt "$CHECK_INTERVAL" ]]; then
            sleep_secs="$until_next"
        else
            sleep_secs="$CHECK_INTERVAL"
        fi

        sleep "$sleep_secs"
    done
}

# -------------------------------------------------------
# Argument parsing
# -------------------------------------------------------
CHAT_ID=""
SCHEDULE=""
MODE="send"
CANCEL_JOB_ID=""
SET_CHAT_ID_VAL=""
SET_BOT_TOKEN_VAL=""
INTERACTIVE=false

[[ $# -eq 0 && -t 0 ]] && { usage; exit 0; }

while [[ $# -gt 0 ]]; do
    case "$1" in
        -c|--chat-id)
            [[ -z "${2-}" ]] && die "$1 requires an argument"
            CHAT_ID="$2"; shift 2 ;;
        -s|--schedule)
            [[ -z "${2-}" ]] && die "$1 requires an argument"
            SCHEDULE="$2"; shift 2 ;;
        -i|--interactive)
            INTERACTIVE=true; shift ;;
        --set-bot-token)
            [[ -z "${2-}" ]] && die "--set-bot-token requires an argument"
            MODE="set-bot-token"; SET_BOT_TOKEN_VAL="$2"; shift 2 ;;
        --set-chat-id)
            [[ -z "${2-}" ]] && die "--set-chat-id requires an argument"
            MODE="set-chat-id"; SET_CHAT_ID_VAL="$2"; shift 2 ;;
        --list-jobs)
            MODE="list"; shift ;;
        --cancel)
            [[ -z "${2-}" ]] && die "--cancel requires a job ID"
            MODE="cancel"; CANCEL_JOB_ID="$2"; shift 2 ;;
        --setup)
            MODE="setup"; shift ;;
        --daemon-loop)
            MODE="daemon"; shift ;;
        -h|--help)
            usage; exit 0 ;;
        *)
            die "Unknown option: $1" ;;
    esac
done

# -------------------------------------------------------
# Mode dispatch
# -------------------------------------------------------
case "$MODE" in
    setup)
        show_setup; exit 0 ;;

    set-bot-token)
        save_bot_token "$SET_BOT_TOKEN_VAL"; exit 0 ;;

    set-chat-id)
        save_chat_id "$SET_CHAT_ID_VAL"; exit 0 ;;

    list)
        list_jobs; exit 0 ;;

    cancel)
        cancel_job "$CANCEL_JOB_ID"; exit 0 ;;

    daemon)
        run_daemon_loop ;;

    send)
        BOT_TOKEN=$(resolve_bot_token) || die "Bot token is not configured.
Run 'send-telegram --set-bot-token <token>' or 'send-telegram --setup' for instructions."

        if [[ -z "$CHAT_ID" ]]; then
            CHAT_ID=$(load_default_chat_id)
            [[ -z "$CHAT_ID" ]] && die "No chat_id specified. Use -c <id> or save a default with --set-chat-id <id>"
        fi

        if [[ -t 0 ]]; then
            if [[ "$INTERACTIVE" == true ]]; then
                echo "Enter message (Ctrl+D to send):" >&2
            else
                usage; exit 0
            fi
        fi
        MESSAGE=$(cat)
        [[ -z "$MESSAGE" ]] && { usage; exit 0; }

        if [[ -n "$SCHEDULE" ]]; then
            SEND_AT=$(parse_schedule "$SCHEDULE")

            if [[ "$SEND_AT" -le "$(date +%s)" ]]; then
                send_message "$BOT_TOKEN" "$CHAT_ID" "$MESSAGE"
            else
                if [[ "$OS" == "Darwin" ]]; then
                    TARGET_TIME=$(date -r "$SEND_AT" "+%Y-%m-%d %H:%M:%S")
                else
                    TARGET_TIME=$(date -d "@${SEND_AT}" "+%Y-%m-%d %H:%M:%S")
                fi

                JOB_ID=$(write_job "$BOT_TOKEN" "$CHAT_ID" "$SEND_AT" "$MESSAGE")
                echo "Queued: ${JOB_ID}" >&2
                echo "Will send at: ${TARGET_TIME}" >&2
                ensure_daemon
            fi
        else
            send_message "$BOT_TOKEN" "$CHAT_ID" "$MESSAGE"
        fi
        ;;
esac
